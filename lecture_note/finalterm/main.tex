\hypertarget{csed101-uxd504uxbc0d-uxae30uxb9d0}{%
\section{CSED101 프밍 기말}\label{csed101-uxd504uxbc0d-uxae30uxb9d0}}

\hypertarget{uxbaa9uxcc28}{%
\subsection{목차}\label{uxbaa9uxcc28}}

\begin{itemize}
\tightlist
\item
  AI Project
\item
  Data Structure
\item
  Object Oriented Programming
\item
  Sort and Search
\item
  Recursion
\item
  GUI Programming
\item
  Numpy and Pandas
\end{itemize}

\hypertarget{ai-project}{%
\subsection{1. AI Project}\label{ai-project}}

\hypertarget{introduction}{%
\subsubsection{1-1. introduction}\label{introduction}}

\begin{itemize}
\tightlist
\item
  AI: 컴퓨터가 사람처럼 생각하고 판단하게 만드는 기술
\item
  ML: AI의 한 분야. 인간의 학습 능력과 같은 기능을 컴퓨터에 부여하기
  위한 기술
\item
  DL: 인공신경망 기반으로 한 ML 방법론 중 하나. 빅데이터 기반으로 스스로
  학습하여 판단하는 기술
\item
  파이썬이 AI에 준 영향: 인공지능 코딩이 쉽고, 인공지능 관련한 다양한
  라이브러리가 존재하며, 메모리를 자동으로 관리하여 간편하다는 장점이
  있다.
\end{itemize}

\hypertarget{machine-learning-type}{%
\subsubsection{1-2. machine learning type}\label{machine-learning-type}}

\begin{itemize}
\tightlist
\item
  supervised: 문제와 정답을 알려주고 공부. (키워드: 예측, 분류)
\item
  unsupervised: 답을 가르쳐주지 않고 공부. (키워드: 연관 규칙, 군집)
\item
  reinforcement: 보상을 통해 상을 최대화, 벌을 최소화하는 방향으로 학습.
  (키워드: 보상)
\end{itemize}

\hypertarget{examples}{%
\subsubsection{1-3. examples}\label{examples}}

\begin{itemize}
\tightlist
\item
  Computer Vision: 컴퓨터가 이미지나 비디오 해석

  \begin{itemize}
  \tightlist
  \item
    Object Detection: 이미지에서 의미 있는 객체의 종류와 위치(bounding
    box) 찾음
  \item
    Object Tracking: 비디오에서 움직이는 객체를 식별하고 추적
  \item
    Face Recognition: 이미지, 비디오에서 얼굴을 인식하고 식별

    \begin{itemize}
    \tightlist
    \item
      보로노이 알고리즘: 얼굴에 점을 찍어서 얼굴 인식함.
    \end{itemize}
  \item
    Image Generation: 텍스트나 다른 이미지 기반으로 새로운 이미지 생성
  \end{itemize}
\item
  NLP: 컴퓨터가 인간의 언어를 이해하고 생성함

  \begin{itemize}
  \tightlist
  \item
    Machine Translation: 번역
  \item
    Chatbot and Conversational System: 챗봇 및 대화. chatbot은 데이터가
    부족하여 영화 대본을 기반으로 만듦.
  \item
    Sentiment Analysis: 감정 분석
  \item
    Text Summarization: 텍스트 요약
  \end{itemize}
\item
  예시: 헬로미러, 얼굴 인식 인공지능 스피커, 자율주행 및 장애물
  회피(POSLA, RC Car, 자동 쇼핑카트), 군집 주행 드론, 주가 예측, 시험
  부정 방지, 메타버스 토론(?)
\end{itemize}



\hypertarget{data-structure}{%
\subsection{2. Data Structure}\label{data-structure}}

\begin{itemize}
\tightlist
\item
  False, None, 0, 0.0, '\,', {[}{]}, (), \{\}, set()은 다 거짓
\item
  \textbackslash0: 문자열 끝내는 널 문자이지만, 파이썬은 문자열 안의
  일반 문자로 취급함
\item
  (un)packing: 값들을 리스트로 묶는 것/리스트의 각 원소를 따로 떼어내어
  변수로 저장하는 것
\item
  list comprehension: 리스트 생성하기 위한 간결하고 표현력 높은 문법.
  {[}expression for item in iterable{]} 형태임

  \begin{itemize}
  \tightlist
  \item
    expression: 현재의 item에 대한 연산이나 처리 결과
  \item
    item: iterable에서 현재 항목 나타냄
  \item
    iterable: 순회 가능한 객체로 list, tuple, string 등이 해당됨
  \item
    filtering: {[}exp for item in iter if {[}조건{]}{]}으로 filtering이
    가능하다. {[}i if i\%2==0 else 99 for i in range(100){]}처럼 else
    넣어서 조건 만족하지 않을 시의 값도 저장 가능. {[}i+j for i in w1
    for j in w2{]}로 nest loop만들 수 있다. 이때, w1에 나오는 값 고정
    후에 w2의 값을 가져와 결과를 생성하게 된다.
  \item
    {[}{[}i for i in range(10){]} for j in range(5){]}로 뒤에 있는 거
    먼저 실행하는 것도 가능하다. 이때는, {[}{[}list1{]}, {[}list2{]},
    \ldots{]}와 같이 저장된다.
  \end{itemize}
\item
  default argument: 함수에 매개변수 전달하지 않았을 때 기본적으로
  매개변수에 설정되는 값이다. 이때, default argument 있는 매개변수는
  항상 맨 뒤쪽에 모여있어야 한다.
\item
  variable length argument(가변 인수): def func(*args)는 임의의 개수의
  인자를 tuple로 전달할 수 있게 해준다. func(1,2)가 가능하다.
\item
  keyword variable length argument(키워드 가변 인수): def
  func(**kwargs)는 임의의 개수의 키워드 인자를 dictionary로 전달할 수
  있게 해준다. func(a=1,b=2)가 가능하다.
\item
  stack: LIFO 구조이다.
\item
  queue: FIFO 구조이다.
\item
  set: 순서 없이 저장되며 중복을 불허한다.

  \begin{itemize}
  \tightlist
  \item
    합집합 I, 교집합 \&, 차집합 - 연산이 가능하다. 각각은 s1.union(s2),
    intersection, difference라는 함수로도 쓸 수 있다.
  \end{itemize}
\item
  collections: 파이썬 내장 모듈이다.

  \begin{itemize}
  \tightlist
  \item
    deque: 양쪽 끝에서 삽입과 삭제가 모두 가능하다. 스택과 큐를 모두
    지원하는 것이다.
  \item
    OrderedDict: 입력된 순서대로 key-value를 저장한다. key 혹은 value로
    데이터 정렬이 가능하다.
  \item
    Counter: 데이터 값의 개수를 dictionary 형태로 반환한다. 리스트 안에
    중복되는 데이터가 있으면 \{{[}데이터{]}:{[}개수{]},\ldots\} 형태의
    리스트로 반환하는 함수이다.
  \end{itemize}
\end{itemize}



\hypertarget{object-oriented-programming}{%
\subsection{3. Object Oriented
Programming}\label{object-oriented-programming}}

\hypertarget{oop}{%
\subsubsection{3-1. OOP}\label{oop}}

\begin{itemize}
\tightlist
\item
  procedure programming: 프로그램 구성하는 데이터와 procedure 분리하여
  접근. 명령어 순서와 함수 호출에 따라 프로그램 작동되는 것을 강조.
  함수는 입력된 인수 가지고 작동한 뒤 결과를 반환함. 단순하고 구조화하기
  쉬움.
\item
  oop: 프로그램을 데이터 \& 함수를 하나로 묶은 객체로 보는 관점. 객체는
  각자의 특성이 존재함. 모듈화 쉬움. 대규모 프로그램 작성에 유용함.
\item
  procedure programming은 함수 중점, oop는 객체 중점.
\item
  oop는 일상생활 문제를 사람의 시각에서 사물을 바라보는 관점으로
  프로그램을 설계하고자 함
\item
  어떤 기능을 함수 코드에 묶어두는 것이 아닐 데이터와 처리하는 기능을
  묶은 하나의 단일 프로그램을 객체라고 하는 코드에 넣어 다른
  프로그래머가 재사용할 수 있게 하는 컴퓨터 공학의 오래된 프로그래밍
  기법 중 하나.
\end{itemize}

\hypertarget{adt}{%
\subsubsection{3-2. ADT}\label{adt}}

\begin{itemize}
\tightlist
\item
  ADT: 데이터와 데이터에 작용하는 연산들로 구성된 수학적 모델. 데이터
  구조의 논리적인 측면 정의하고, 데이터와 연산의 관계를 추상화하여
  정의함.

  \begin{itemize}
  \tightlist
  \item
    데이터와 연산을 분리하여 내부 구현을 감춤. 데이터와 데이터 조작하는
    연산을 분리함. 프로그램의 모듈화를 촉진하고 데이터 구조를 보다
    추상화하는 장점이 있음
  \item
    모듈화, 추상화: 코드 가독성과 유지보수 및 재사용성 증가됨.
  \item
    재사용성: ADT 통해서 만든 데이터 구조와 연산을 여러 프로그램에
    재사용 가능하며, 데이터 구조 변경하지 않고 연산을 수정하거나 대체할
    수 있음
  \item
    알고리즘과 데이터 구조 독립성: 서로 독립적인 개발이 가능하여, 코드
    유연성 증가되고, 새로운 알고리즘을 동일한 데이터 구조에 적용할 수
    있음.
  \item
    인터페이스 명확성: 데이터와 연산의 인터페이스 명확하게 정의할 수
    있기 떄문에 프로그램의 구조 이해가 쉬움.
  \end{itemize}
\item
  abstraction: 복잡한 현실 세계를 모델링하여 단순화하는 과정. 추상화로
  핵심적인 특징 추출한 뒤, 이를 객체의 속성(property)와 기능(method)로
  표현
\item
  ADT는 연산이 무엇인지는 알 수 있지만 어떻게 동작하는지는 알 수 없다.
  사용자는 사용법만 알면 데이터 타입을 쉽게 쓸 수 있음. 객체지향은
  class로 ADT 구현
\item
  interface: 두 대상이 정보를 주고 받는 경계
\item
  public: 정보 접근 제한자. 파이썬의 기본 접근 제한자이며, class 밖에서
  접근을 허용한다.
\item
  private: 정보 접근 제한자. 파이썬에서는 이름 앞에 ``\_\_''를 붙여서
  class 밖에서의 접근을 막을 수 있다.
\item
  dynamic memory: 런타임에 사용할 메모리 공간을 할당하는 것을 의미.
\end{itemize}

\hypertarget{class}{%
\subsubsection{3-3. class}\label{class}}

\begin{itemize}
\tightlist
\item
  class: 데이터, 함수 묶어서 선언할 수 있도록 만들어진 user defined data
  type.
\item
  파이썬에서 모든 객체는 object라는 개념을 사용하여 저장한다. 기본
  데이터 타입도 전부 객체이며 각 객체는 identity, type, value를 가진다.
  이때, class는 사용자 정의 객체를 만드는데 사용하는 메커니즘인 것이다.
\item
  class의 속성을 field라고 하며 여기에 추상화한 데이터들을 선언한다.
  기능은 function으로 구현하며, 이렇게 class 안에 구현된 함수를
  method라고 부른다.
\item
  instance: class로 만든 실제 물리적 객체. class를 하나의 틀로 하여 만든
  객체이다. 각 instance에는 별개의 field가 존재하여 별도의 값을
  저장가능하다.
\item
  class에는 여러 특수 method들이 있으며, 대표적인 예는 다음과 같다.

  \begin{itemize}
  \tightlist
  \item
    \textbf{init}: constructor. instance 생성 시에 무조건적으로 호출되는
    특수 method. 기본 constructor는 매개변수가 self만 있음.
  \item
    \textbf{del}: destructor. instance 소멸 시에 무조건적으로 호출되는
    특수 method.
  \item
    \textbf{str}: print()의 매개변수로 instance가 들어간 경우, 이
    method의 반환 값이 print 됨.
  \item
    \textbf{len}: len()의 매개변수로 instance가 들어간 경우, 이 method의
    반환 값이 함수 반환값 됨.
  \end{itemize}
\item
  instance variable: 각각의 instance마다 할당된 변수.
  instance\_name.variable로 가져온다.
\item
  class variable: class 안에 공간이 할당된 변수. class\_name.variable로
  가져온다.
\item
  class variable은 field에, instance variable은 \_\_init\_\_안에 self를
  붙여서 선언하는 것이 일반적이지만, 전부 field에 선언한 후 필요할 때
  instance.variable = 10과 같이 써서 class variable을 shadowing 할 수
  있다.
\end{itemize}

\hypertarget{oop-features}{%
\subsubsection{3-4. OOP features}\label{oop-features}}

\begin{itemize}
\tightlist
\item
  encapsulation: 객체의 상태(state), 행위(behavior)를 하나로 묶고,
  외부에서의 접근을 제한하여 객체를 보호하는 과정. encapsulation으로
  객체의 내부 구조를 감추고 외부에 제공하는 interface만 노출

  \begin{itemize}
  \tightlist
  \item
    information hiding: 데이터 보호 위해 다른 객체 접근 제한하는 접근
    제한 수식자 기능 제공
  \end{itemize}
\item
  inheritance: 기존 클래스 필드와 매소드를 물려받아 그것을 기반으로
  새로운 클래스 만드는 과정. 기존 클래스 속성과 기능을 재사용하고 새로운
  기능 추가하여 코드 간결하게 작성 가능.
\item
  상위 class를 super class, parent class라고 하고, 하위 클래스를
  subclass, child class라고 함.
\item
  method overriding: super class의 method를 subclass에서 재정의하는 것.
\item
  operator overloading: 사용자 정의 객체에서 필요한 연산자를 내장 타입과
  형태와 동작이 유사하도록 재정의. 두 개의 밑줄 문자가 앞뒤로 있는
  메소드를 미리 정의함.

  \begin{itemize}
  \tightlist
  \item
    산술: \textbf{add}, \textbf{sub}, \textbf{mul}, \textbf{truediv},
    \textbf{floordiv}, \textbf{mod}, \textbf{divmod}(몫, 나머지를
    tuple로 반환), \textbf{pow}, \textbf{ishift}
  \item
    관계: \textbf{lt}, \textbf{le}, \textbf{eq}, \textbf{ne},
    \textbf{gt}, \textbf{ge}
  \item
    논리: \textbf{and}, \textbf{or}, \textbf{xor}, \textbf{neg}(-),
    \textbf{invert}(\textasciitilde)
  \item
    a{[}key{]}: \textbf{getitem}, \textbf{setitem}
  \item
    피연산자 순서가 바뀐 경우, r 붙인 method를 정의. 즉, instance+100은
    add에서 처리하며, 100+instance은 radd에서 처리.
  \item
    연산자에 =가 붙은 경우, i 붙인 method를 정의한다. 즉, a+=b는
    iadd에서 처리한다. 이때, 연산 수행후 self나 instance 등을
    return해주어야 한다. 이는 v1+=v2가 v1=v1+v2로 쪼개져 동작하기 때문.
    따라서, iadd는 값 더한 뒤에, 반환한 값이 v1에 들어가는 형식.
  \end{itemize}
\item
  polymorphism: 같은 이름의 method가 서로 다른 object에서 다르게
  동작하는 특성. 다형성 통해 코드 재사용성과 유연성 높이고 object 간의
  상호작용을 쉽게 구현한다.

  \begin{itemize}
  \tightlist
  \item
    inheritance 관계 내에 다른 class들의 instance들이 같은 멤버 함수
    호출에 대해 각각 다르게 반응하도록 하는 것, method overriding,
    operator overloading은 polymorphism를 지원하는 기술 중 하나.
  \item
    장점: 적은 코딩으로 다양한 객체에서 유사한 작업 수행 가능하며 코드의
    가독성을 높여줌
  \item
    장점(python): 형 선언이 없기 때문에, polymorphism 적용이 더 용이함.
    실시간으로 객체의 형이 결정되므로 단 하나의 method에 의해 여러
    객체를 처리할 수 있음.
  \end{itemize}
\end{itemize}

\hypertarget{oop-design}{%
\subsubsection{3-5. OOP design}\label{oop-design}}

\begin{itemize}
\tightlist
\item
  시스템 요구 사항 분석하고, 효율적으로 구현할 수 있는 class로 변환하는
  과정

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    요구 사항 분석

    \begin{itemize}
    \tightlist
    \item
      문제 이해하기: 시스템이 해결해야 할 문제를 이해
    \item
      기능적 요구 사항 정의: 시스템이 수행해야 할 기능을 명확히 도출
    \item
      비기능적 요구 사항 정의: 성능, 보안, 사용성 등의 비기능적 요소를
      고려
    \end{itemize}
  \item
    개념 모델링

    \begin{itemize}
    \tightlist
    \item
      도메인 개념 식별: 시스템과 관련된 주요 개념들을 식별
    \item
      속성 정의: 각 개념의 속성을 정의
    \item
      관계 파악: 개념들 사이의 관계를 파악
    \end{itemize}
  \item
    class 도출

    \begin{itemize}
    \tightlist
    \item
      class 후보 선정: 개념 모델링에서 식별된 개념들을 바탕으로 class
      후보를 선정함
    \item
      class 정의: 각 class의 속성(개념 모델링 속성)과 method(시스템
      기능적 요구사항)를 정의.
    \item
      상속 및 연관 관계 설정: class 간의 상속, 연관, 집합, 구성 등의
      관계 정의
    \end{itemize}
  \item
    반복 및 정제

    \begin{itemize}
    \tightlist
    \item
      반복적 검토 및 수정: 설계는 반복적인 과정이며, 새로운 요구사항이
      추가되거나 변경될 때마다 class를 재검토하고 필요에 따라 수정
    \item
      정제: 중복을 제거하고, 불필요한 class를 줄이며, class의 책임을
      명확하게 작성
    \end{itemize}
  \item
    문서화 및 검증

    \begin{itemize}
    \tightlist
    \item
      UML 다이어그램 작성: class diagram을 통해 class와 그 관계를
      시각적으로 표현
    \item
      검증: 설계가 모든 요구사항을 충족하는지 검증
    \end{itemize}
  \end{enumerate}
\item
  팁 및 주의사항

  \begin{itemize}
  \tightlist
  \item
    실세계 모델링: OOP 설계는 실세계 문제를 모델링하는 것이므로 실세계의
    개념과 프로세스를 잘 이해하는 것이 중요.
  \item
    유연성 유지: 요구 사항 변경에 유연하게 대응할 수 있는 설계를 고려
  \item
    과도한 세분화 방지: 너무 많은 class로 세분화하는 것은 복잡성
    증가시킬 수 있으므로 주의
  \end{itemize}
\item
  OOP 설계에서 class 도출은 시스템 효율적인 구현과 유지보수에 중요한
  역할. 이 과정은 체계적이고 반복적인 접근을 필요로 함.
\end{itemize}

\hypertarget{class-relations}{%
\subsubsection{3-6. class relations}\label{class-relations}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  상속(inheritance) (is-a): 종속이랑 아예 무관. 한 class가 다른 class를
  받아들이는 것. class의 확장.

  \begin{itemize}
  \tightlist
  \item
    실선 \& 화살표
  \item
    예시: 포유류와 고래. 고래가 포유류를 상속하여 만들어짐. 고래는
    포유류이지만, 포유류가 고래는 아님.
  \end{itemize}
\item
  연관(association) (use-a이지만 instance가 다른 instance를 가지고 여러
  활동을 하기 때문에 has-a로 쓰기도 함): 각 class는 종속 관계가 아님.
  서로에게 소유권이 없음. 서로의 관계 알지만 생명 주기에 영향 없음. 한
  instance가 다른 instance를 쓰는 것이 보편적이기에 has-a로 표현됨.

  \begin{itemize}
  \tightlist
  \item
    점선
  \item
    예시: 선생님과 학생. 서로 관련은 있지만 서로에게 속해있지는 않음.
    서로가 서로의 method에 영향을 주긴 함.
  \end{itemize}
\item
  집약(aggregation) (has-a): association에 whole-part 관계를 추가한
  것으로, 전체가 부분을 포함함. 약한 소유권을 가짐. class가 종속되지는
  않기에 생명 주기에 영향은 없음.

  \begin{itemize}
  \tightlist
  \item
    실선 \& 빈 마름모
  \item
    예시: 부서와 회사원. 부서로 회사원들을 묶을 수는 있지만 완전히
    종속된 것은 아님. 부서를 언제든지 옮길 수 있고, 부서가 없어져도
    사람이 없어지지는 않음.
  \end{itemize}
\item
  구성(composition) (has-a이고, 더 확실하게는 owns-a임): aggregation과
  비슷함. 대신에 강한 소유권을 가짐. class가 종속되기에 생명 주기에 영향
  있음.

  \begin{itemize}
  \tightlist
  \item
    실선 \& 채워진 마름모
  \item
    예시: 집과 방. 집에 방이 속해있고, 집이 없어지면 마찬가지로 방도
    없어짐.
  \end{itemize}
\end{enumerate}

\begin{itemize}
\tightlist
\item
  집합 관계: 집약과 구성이 해당됨. 객체 간의 특별한 형태의 연관 관계를
  나타냄. 둘 다 연관 관계의 한 형태이지만, 객체 간의 의존성과 생명주기에
  따라 명확하게 구분됨. 이러한 관계를 통해 OOP에서 class 간의 상호작용
  및 의존성을 명확하게 표현함.
\item
  association과 aggregation은 그 특성상 코드 상의 구현체에서 큰 차이를
  보기 힘듦. 그러나, 둘은 의미 상의 차이점이 분명히 존재하며,
  association이 보다 약한 개념이고, association은 보통 method
  parameter로 넣어서 한 번씩 쓰는 형태이지만, aggregation은 아예 리스트
  같은 걸 class 안에 만들어놓고 거기에 넣어서 그걸 꺼내서 쓰는 형태임.
\item
  여담으로, C++에서도 정확히 동일한 개념이 쓰임. 이때, inheritance를
  구현하기 위해 public inheritance가 쓰이고, composition을 구현하기 위해
  private inheritance나, containment를 사용함. 이때, 이들을 has-a
  relationship이라고 부름.
\end{itemize}



\hypertarget{sort-and-search}{%
\subsection{4. Sort and Search}\label{sort-and-search}}

\hypertarget{sort}{%
\subsubsection{4-1. sort}\label{sort}}

\begin{itemize}
\tightlist
\item
  sort: 입력된 데이터를 특정한 기준에 따라 오름차순 혹은 내림차순으로
  정렬하는 알고리즘
\item
  bubble sort: 인접한 두 데이터를 비교하여 정렬하는 방법. 처음부터
  끝까지 인접한 원소 비교하여 큰 값을 오른쪽으로 이동시킴. 이렇게
  이동시킨 후, 다시 정렬 작업을 반복. 느리지만 간편함.
\item
  selection sort: 배열에서 최솟값 찾아서 맨 앞의 요소와 교체하는 방법.
\item
  insertion sort: 배열의 두 번째 원소에서 시작하여 앞의 요소들과
  비교하여 삽입할 위치를 결정한 다음에 삽입. selection 보다는 빠르지만
  데이터 크기가 크면 효용성 떨어짐.
\item
  quick sort: 분할 정복 알고리즘. pivot 기준으로 큰 값과 작은 값을
  나누어 각각에 대해 재귀적으로 정렬을 수행. 대부분의 경우에서 가장 빠른
  알고리즘.
\item
  merge sort: 분할 정복 알고리즘. 주어진 배열을 두 부분으로 나눈 뒤,
  각각을 정렬한 후에 다시 합치는 방식. 퀵 정렬과 마찬가지로 대부분의
  경우에 가장 빠름.
\item
  tim sort: python 정렬 알고리즘. 작은 부분 배열은 삽입, 그 부분 배열을
  합치는데 병합 정렬을 이용함. 이미 정렬된 배열이나 거의 정렬된 배열을
  빠르게 처리함.
\item
  sort(): 리스트 내장 함수이며, 반환 값은 None.
\item
  sorted(): 리스트를 받아서 정렬한 결과를 반환하며, 원래 리스트는
  변경되지 않음.
\end{itemize}

\hypertarget{search}{%
\subsubsection{4-2. search}\label{search}}

\begin{itemize}
\tightlist
\item
  search: 데이터에서 원하는 값을 검색
\item
  sequential search(순차 검색): 배열이나 리스트를 앞에서부터 순서대로
  하나씩 비교하여 원하는 값을 찾음. 정렬되지 않은 배열에도 적용
  가능하지만 비효율적임
\item
  binary search(이진 검색): 정렬된 데이터로 검색. 배열의 중간 값을
  검사하여 찾는 값이 더 크면 오른쪽 절반에서 다시 검색, 작으면 왼쪽
  절반에서 다시 검색.
\end{itemize}



\hypertarget{recursion}{%
\subsection{5. Recursion}\label{recursion}}

\begin{itemize}
\tightlist
\item
  재귀 함수: 함수가 자기 자신을 다시 호출하여 문제를 해결하는 프로그래밍
  기법
\item
  반복문처럼 동일한 작업 수행하는 코드를 간결하게 작성. 일부 문제를
  해결하기 위해 더 작은 문제로 분할한 뒤에, 이들을 해결하여 전체 문제를
  해결함. 함수가 자신을 호출하면서 호출 횟수를 제한하는 조건문이
  필수적이며 이러한 조건문이 없을 경우, 무한한 재귀 호출이 발생한다는
  단점이 있음.
\item
  장점: 일부 문제에서 반복문에 비해 코드의 간결해지고, 트리 구조나
  그래프 탐색과 같은 여러 문제들의 해결에 용이함.
\item
  단점: 자기 자신 호출하는 과정에서 stack memory 사용하기에 memory
  사용량 증가하며 반복문보다 함수 호출과 반환에 대한 오버헤드(함수
  호출시에 발생하는 추가적인 작업량)가 크기 때문에 실행 속도가 저하됨.
\item
  하노이 탑: 3개의 기둥에 크기가 다른 원판이 있을 때, 한번에 하나의
  원판을 옮겨서 첫 번째 기둥에 있는 모든 원판을 세 번째 기둥으로 옮기는
  것이다. 이때, 작은 원판 위에 큰 원판을 옮길 수 없다.

  \begin{itemize}
  \tightlist
  \item
    n-1번째를 2번째 기둥으로 옮긴 다음에, n번째를 3번째 기둥으로 옮기고,
    n-1번째를 다시 2번째로 옮긴다.
  \end{itemize}
\end{itemize}



\hypertarget{gui-programming}{%
\subsection{6. GUI Programming}\label{gui-programming}}

\hypertarget{tui-vs-gui}{%
\subsubsection{6-1. TUI vs GUI}\label{tui-vs-gui}}

\begin{itemize}
\tightlist
\item
  TUI(text user interface), GUI(graphic user interface)는 user-computer
  상호작용 위한 주요한 인터페이스 유형.
\item
  TUI: 텍스트 기반. 콘솔이나 명령 줄로 알려져 있음. 사용자는 명령어를
  입력하고 텍스트 기반 정보를 받아들이며 키보드 이용하여 상호작용. MS
  DOS, linux shell, 편집기인 vim 등이 있음

  \begin{itemize}
  \tightlist
  \item
    장점: 자원 소모가 적고 경량. 텍스트 기반이라 console에서도 사용
    가능. 간단하고 빠르며, 스크립트와의 통합이 용이함.
  \item
    단점: 사용자가 명령어나 옵션 기억하고 입력해야 함. 그래픽 요소
    제한적이기에 복잡한 시각적 표현 어려움
  \end{itemize}
\item
  GUI: 그래픽 요소 사용하여 사용자와 상호작용. 사용자는 윈도우, 버튼,
  메뉴, 입력 필드와 같은 요소를 마우스로 조작함.

  \begin{itemize}
  \tightlist
  \item
    장점: 시각적인 요소로 직관적인 환경을 제공하며, 복잡한 작업을
    그래픽으로 간단하게 수행함. 다양한 입력 방식 지원하여 사용자 편의성
    높임.
  \item
    단점: 자원 소모 크고, 구현과 디자인에 시간이 많이 걸림. 다양한
    플랫폼에서 동일한 모습을 유지하기가 힘듦.
  \end{itemize}
\end{itemize}

\hypertarget{tkinter}{%
\subsubsection{6-2. tkinter}\label{tkinter}}

\begin{itemize}
\tightlist
\item
  파이썬은 tkinter, pyqt, pyside, kivy, wxpython 등의 도구 지원.
\item
  tkinter: 파이썬 표준 라이브러리이며, 문법과 구조가 상대적으로 단순하며
  별도의 설치가 필요 없다는 장점이 있다. 또한, tkinter는 다음의 특징을
  갖는다.

  \begin{itemize}
  \tightlist
  \item
    크로스 플랫폼 지원: 파이썬은 크로스 플랫폼 개발을 지원하므로 동일한
    코드를 사용하여 여러 플랫폼에서 GUI 애플리케이션을 실행할 수 있다.
  \item
    확장성: 파이썬은 다른 언어와의 통합이 용이하며, C/C++로 작성된
    라이브러리의 결합을 통해 추가적인 기능을 제공할 수 있다. PyQT,
    wxPython은 Qt, wxWidgets라는 C++ 기반 프레임워크 이용할 수 있다.
  \item
    풍부한 기능과 widget: 다양한 기능과 widget을 제공하여 사용자
    인터페이스를 다양하게 구성할 수 있음. 버튼, 레이블, 텍스트 상자,
    체크박스, 라디오 버튼, 드롭다운 메뉴 등의 위젯 활용할 수 있음.
    그래픽 요소도 처리할 수 있기 때문에, 도표, 차트, 이미지 표시와 같은
    고급 기능을 개발하는데 유용함.
  \item
    데이터 시각화: matplotlib, seaborn, plotly 등을 이용하여 데이터
    시각적으로 표현하고 그래프, 플롯, 차트 등을 생성할 수 있음. 데이터
    시각화는 데이터 분석 및 보고에 필수적인 요소로 사용이 가능함.
  \end{itemize}
\item
  위젯(widget): 사용자 인터페이스를 구성하는 요소. 다양한 인터렉션
  요소를 포함.
\item
  위젯들은 사용자와 애플리케이션 간의 상호작용 담당하며 애플리케이션
  기능 제어하고 정보를 표시하는 역할을 함

  \begin{itemize}
  \tightlist
  \item
    label: 사용자에게 텍스트나 이미지 표현
  \item
    button: 사용자가 클릭할 수 있는 버튼
  \item
    entry: 사용자로부터 텍스트를 입력받을 수 있는 상자
  \item
    checkbutton: 사용자가 체크할 수 있는 옵션을 표시. 여러 개의 체크
    박스를 그룹으로 묶어 다중 선택 가능함
  \item
    radiobutton: 여러 개의 옵션 중 하나를 선택할 수 있는 버튼. 여러 개의
    라디오 버튼을 그룹으로 묶어 단일 선택 가능함
  \item
    listbox: 여러 항목을 리스트 형태로 표시하고 사용자가 선택할 수 있게
    하며, 단일 선택과 다중 선택이 가능함
  \item
    combobox: 텍스트 상자와 드롭다운 목록을 결합한 widget. 사용자가
    선택할 수 있는 목록을 제공하며, 자유롭게 텍스트 입력 가능함
  \item
    text: 여러 줄의 텍스트를 입력하거나 표시하는데 사용. 대용량 텍스트
    편집 가능하며 스크롤바 포함 가능함.
  \end{itemize}
\item
  window=tk.Tk(): Tk class로 주 창을 생성. 루트 윈도우를 초기화.
\item
  window.title(): 창 제목 설정
\item
  {[}widget{]} = tk.Entry(): 입력 창 설정. input\_entry.get()으로 입력된
  값 받아옴.
\item
  {[}widget{]}.pack(): 화면에 배치. 자동으로 배치됨.
\item
  {[}widget{]}.config(): 속성을 변경.
\item
  window.mainloop(): tkinter 애플리케이션의 이벤트 루프를 실행. 이벤트
  처리하고 창을 업데이트하는데 사용됨.
\item
  canvas.bind(''\textless{[}keyname{]}\textgreater'', lambda event:
  {[}event{]}): canvas에서 발생하는 키 입력을 bind한다.
\item
  outline, create\_oval, create\_rectangle, create\_triangle. 각각은
  outline(테두리 색상), fill(내부 색상), width(테두리 두께)등의 속성이
  있다.
\end{itemize}



\hypertarget{numpy-and-pandas}{%
\subsection{7. Numpy and Pandas}\label{numpy-and-pandas}}

\hypertarget{numpy}{%
\subsubsection{7-1. numpy}\label{numpy}}

\begin{itemize}
\tightlist
\item
  scalar: 크기만 가지고 방향 가지지 않는 수. 실수 정수 복소수 등이 예시.
  한 개의 값
\item
  vector: 크기와 방향을 가지는 수. 여러 개의 값을 가지며 순서가 중요함.
\item
  matrix: 2차원 배열. 행과 열의 요소를 가짐. 각 요소는 스칼라이며, 행과
  열에 따라 위치가 결정. 선형 변환, 선형 방정식, 데이터 표현 등에 널리
  이용됨.
\item
  vector, matrix를 표현하기 위해 numpy를 주로 이용. 벡터와 행렬을
  다루는데 굉장히 유용한 도구이며, 벡터와 행렬에서 다양한 변환과 연산을
  효율적으로 수행할 수 있음. numpy 사용하여 선언한 벡터와 행렬은 다양한
  수학 연산 지원.
\item
  numpy: 파이썬에서 수치 계산을 위한 핵심 라이브러리로 널리 사용되는
  도구. 다차원 배열 객체와 배열 처리에 대한 다양한 함수와 method를
  제공하여 과학적이고 수치적인 계산을 효율적으로 수행함.
\item
  list 장점

  \begin{itemize}
  \tightlist
  \item
    유연성: list는 다양한 데이터 유형을 포함할 수 있으며 크기가 동적으로
    조정될 수 있음.
  \item
    내장 함수: 다양한 내장 함수와 method가 있어 데이터 조작과 분석이
    쉬움
  \end{itemize}
\item
  list 단점

  \begin{itemize}
  \tightlist
  \item
    속도: 연산이 반복문 통해서 요소 별로 수행되기에 큰 데이터 셋에서
    속도가 느림
  \item
    메모리 사용: 각 요소에 대한 정보 저장하기 위해 추가적인 메모리
    공간을 이용하여 큰 데이터 셋에서 메모리 사용이 비효율적임
  \end{itemize}
\item
  numpy 장점

  \begin{itemize}
  \tightlist
  \item
    성능: 배열이 C로 구현되어 있기 때문에 반복문 쓰지 않고 벡터화된 연산
    수행할 수 있어 처리 속도가 빠름.
  \item
    메모리 사용: 연속된 공간에 데이터 저장하여 메모리 사용이 효율적
  \item
    다차원 배열 지원: 다차원 배열 지원하여 행렬 연산 및 다차원 데이터
    처리가 용이
  \item
    다양한 수학 함수: 다양한 수학 함수와 연산을 제공함
  \end{itemize}
\item
  numpy 단점

  \begin{itemize}
  \tightlist
  \item
    유연성: 한 가지 데이터 유형만 포함할 수 있고, 크기를 동적으로 조정할
    수 없음. 크기 변경하려면 새로운 배열 만들어야 함.
  \item
    추가 기능의 부족: 기본적인 수학과 배열 조작에 중점을 둔 함수밖에
    없어서 추가 기능이 제한적일 수 있음.
  \end{itemize}
\item
  파이썬 배열 느린 이유: 리스트가 연속된 배열로 된 값이 아니라, 연속된
  주소의 배열을 가지고 있고 그 주소가 리스트의 각기 다른 요소를 가리키는
  방식.
\item
  주요 함수
\end{itemize}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
array()
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
배열 생성. 리스트나 튜플 객체 입력 받아 numpy 배열로 변환
\end{minipage} \\
\midrule
\endhead
zeros() & 모든 요소가 0 \\
ones() & 모든 요소가 1 \\
arange() & 주어진 범위 내에서 일정한 간격으로 값이 증가하는 1차원
배열 \\
linspace() & 주어진 범위 내에서 지정된 개수에 맞춰서 일정한 간격으로 값
증가하는 1차원 배열 \\
reshape() & 배열의 차원과 크기 재조정 \\
transpose() & 전치 \\
concatenate() & 여러 배열을 연결함. 특정 축을 따라 배열을 연결할 수
있음. \\
sum() & 모든 요소의 합 \\
mean() & 모든 요소의 평균 \\
max, min() & 최대, 최소 \\
matmul() & 행렬 곱 \\
sort() & 배열 정렬. 특정 축 기준으로 할 수 있음. \\
argmax() & 최댓값의 index. 특정 축 기준으로 할 수 있음. \\
argmin() & 최솟값의 index. 특정 축 기준으로 할 수 있음. \\
\bottomrule
\end{longtable}

\hypertarget{pandas}{%
\subsubsection{7-2. pandas}\label{pandas}}

\begin{itemize}
\tightlist
\item
  pandas: 데이터 조작과 분석 위한 라이브러리. 강력한 데이터 구조와
  데이터 조작 기능 제공하여 데이터를 쉽게 조작하고 분석할 수 있게 해줌.
\item
  Series: 1차원 배열과 같은 자료구조. 각 요소는 index, value로 구성되어
  있으며 index는 각 요소에 대한 고유한 이름 또는 레이블이고, 한 가지
  데이터 유형으로 구성된 열을 나타내는데 사용함
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\toprule
head(n) & 처음 n개 요소 반환 (기본값은 5) \\
\midrule
\endhead
tail(n) & 마지막 n개 요소 반환 (기본값은 5) \\
index & series의 인덱스 반환 \\
values & series의 값 반환 \\
dtype & series의 데이터 타입 반환 \\
size & series의 데이터 개수 반환 \\
shape & series의 형태를 반환. 크기를 튜플 형태로 표현 \\
describe() & 기술 통계량 요약하여 반환(평균, 표준편차, 최소, 최대) \\
mean() & 평균 \\
sum() & 합 \\
min(), max() & 최소, 최대 \\
std() & 표준편차 \\
median() & 중앙값 \\
value\_counts() & 각 값의 빈도를 계산하여 반환 \\
sort\_values() & 값 기준 정렬 \\
iloc() & index 기반으로 데이터 접근하는 함수 \\
isnull() & 누락된 값 나타내는 boolean 반환 \\
fillna(value) & 누락된 값을 지정한 값으로 채움 \\
\bottomrule
\end{longtable}

\begin{itemize}
\tightlist
\item
  DataFrame: 2차원 테이블과 같은 자료구조. 여러 개의 series를 모아서
  column으로 구성하며, 각 column은 다른 데이터 유형을 가질 수 있음. 행은
  dataframe에서 하나의 데이터 레코드 의미하며 각 행은 index 가지고 있음.
\end{itemize}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule
\begin{minipage}[b]{\linewidth}\raggedright
pd.DataFrame(data,index,columns)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
데이터프레임 생성 함수. index는 행 index, columns는 열 index 저장.
data는 데이터 입력하는 인자
\end{minipage} \\
\midrule
\endhead
head(n) & 첫 n개 행을 반환 (기본값은 5) \\
tails(n) & 첫 n개 열을 반환 (기본값은 5) \\
info() & 기본 정보를 출력(열의 데이터 타입, 결측치 유무, 메모리
사용량) \\
describe() & 숫자형 열에 대한 기술 통계 정보 출력(평균, 표준편차,
최대최소, 사분위수) \\
shape & 행, 열의 크기 반환 \\
columns & 열의 index 반환 \\
index & 행의 index 반환 \\
values & 값을 2차원 배열 형태로 반환 \\
loc{[}row\_label, column\_label{]} & label 이용하여 행과 열을 선택 \\
iloc{[}row\_index, column\_index{]} & 위치 이용하여 행과 열을 선택 \\
isnull() & 결측치 있는 위치를 확인하여 boolean 형태로 반환 \\
dropna() & 결측치 있는 행 또는 열을 삭제 \\
fillna(value) & 결측치를 value로 채움 \\
sort\_values(column) & 열 기준으로 데이터프레임 정렬. 기본적으로
오름차순이며, ascending=False로 내림차순으로 정렬 가능. \\
\bottomrule
\end{longtable}
