\section[{8. Data Structure - {\it 데이터 구조}}]{8. Data Structure}

\subsection{List}

\textbf{리스트}\textit{\textsuperscript{List}}는 여러 개의 값을 저장할 수 있는 자료형이다. 여러 개의 숫자나 문자들을 하나의 변수에 담고 싶을 때 리스트를 사용할 수 있다. 리스트에 저장된 값은 순서가 있으며, 값을 변경할 수 있다. 또한, 여러 데이터 타입을 하나의 리스트에 저장할 수 있다.

파이썬에서 리스트는 대괄호("[]")를 이용하여 로 생성할 수 있다. 다음은 리스트를 만드는 예제이다.

\begin{tcolorbox}[colframe=black, colback=white]
\begin{minted}{python}
my_list = [1, 2, 3]
empty_list = []
\end{minted}
\end{tcolorbox}

리스트에서 특정 위치의 값에 접근하거나 변경하려면 \textbf{인덱스}\textit{\textsuperscript{Index}}를 사용해야 한다. 인덱스는 0부터 시작하기 때문에 이를 유의해야 한다. 다음은 리스트의 5번째 값을 가져오고 4번째 값을 -1로 수정하는 예제이다.

\begin{tcolorbox}[colframe=black, colback=white]
\begin{minted}{python}
fifth_value = my_list[4]
my_list[3] = -1
\end{minted}
\end{tcolorbox}

다음은 여러 리스트 관련 기능을 분류한 것이다. 각 분류는 이름을 포함하여 알아두는 것이 좋다.

\begin{itemize}
    \item \textbf{슬라이싱}\textit{\textsuperscript{Slicing}}: list{[}a,b{]}와 같이 입력하여 인덱스 a부터 b-1까지의 원소를 자르고 반환할 수 있다. 비슷하게, list{[}a:{]}는 인덱스 a부터 끝 원소까지, list{[}:a{]}는 처음부터 인덱스 a-1 원소까지를 반환한다.
    \item \textbf{합치기}\textit{\textsuperscript{Concatenate}}: 더하기 +를 이용하여 두 리스트를 합친다.
\begin{tcolorbox}[colframe=black, colback=white]
    \begin{minted}{python}
x = [1, 2]
y = [3, 4, 5]
print(x + y) # [1, 2, 3, 4, 5] 출력
    \end{minted}
    \end{tcolorbox}
    \item \textbf{반복}\textit{\textsuperscript{Multiply}}: 곱하기 *를 이용하여 list를 반복하여 더할 수 있다.
\begin{tcolorbox}[colframe=black, colback=white]
    \begin{minted}{python}
x = [1, 2, 3]
print(x * 3) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 출력
    \end{minted}
    \end{tcolorbox}
    \item \textbf{삭제}\textit{\textsuperscript{Delete}}: 특정 인덱스 범위의 값 전체를 삭제하기 위해서는 list{[}a:b{]}={[}{]}와 같이 입력한다. 이 코드는 리스트의 인덱스 a부터 인덱스 b-1까지 원소를 삭제한다.
\begin{tcolorbox}[colframe=black, colback=white]
    \begin{minted}{python}
x = [1, 2, 3, 4, 5]
x[2:4] = []
print(x) # [1, 2, 5] 출력
    \end{minted}
    \end{tcolorbox}
    \item \textbf{언패킹}\textit{\textsuperscript{Unpacking}}: list를 분해하여 각 원소를 새로운 변수에 담는다.
    \begin{tcolorbox}[colframe=black, colback=white]
    \begin{minted}{python}
p = [1, 2]
a, b = p # a, b에 각각 1, 2가 담기게 된다.
    \end{minted}
    \end{tcolorbox}
    \item zipping: 2개 이상의 list를, 각 list의 같은 index 원소끼리 묶어서 tuple로 반환한다. zip 함수를 이용한다.
        \begin{tcolorbox}[colframe=black, colback=white]
    \begin{minted}{python}
a = [1, 2]
b = [3, 4]
print(zip(a, b)) # [[1, 3], [2, 4]] 출력
    \end{minted}
    \end{tcolorbox}
\end{itemize}

아래의 연산자는 if 문이나, while 문의 조건으로 사용될 수 있는 연산자이다.

\begin{itemize}
\item \textbf{in, not in 연산자}: list에 element가 포함되었는지 체크하는 연산
\end{itemize}

\begin{minipage}{\textwidth}
\begin{tcolorbox}[colframe=black, colback=white]
\begin{minted}{python}
x = ['a', 'b', 'c']
if 'b' in x:
    print("x has b")
\end{minted}
\end{tcolorbox}
\textbf{결과: }
\fbox{\texttt{x has b}}
\end{minipage}

위에서 설명한 in, not in 연산자는 tuple, set, dictionary에서도 사용할 수 있는 범용적인 연산자이며, 다양한 상황에서 응용되니 기억해두어야 한다.

아래는 리스트 관련 각종 함수를 나타낸 것이다.

\begin{longtable}[]{@{}p{4cm} p{10cm}@{}}
    \toprule
    함수 이름 & 설명 \\
    \midrule
    \endhead
    list.append(x) & list 뒤에 x 추가 \\
    list.pop() & 맨 뒤 원소 반환하고 삭제 \\
    list.sort() & 정렬 \\
    list.reverse() & 순서 역순 \\
    list.index(x) & x 찾아서 반환 \\
    list.insert(loc, x) & loc에 x 삽입 \\
    list.remove(x) & x 제거. 여러 개 있으면 첫 번째만 \\
    list1.extend(list2) & list1 뒤에 list2 추가하여 확장. +와 동일한 역할 \\
    list.count(x) & list 내부에 찾을 값 x의 개수 \\
    del(list{[}pos{]}) & list에서 위치 pos의 항목 삭제 \\
    len(list) & list 전체 항목 개수 \\
    zip(list1, list2) & list1과 list2를 같은 index끼리 묶기 \\
    \bottomrule
\end{longtable}

\subsection{Tuple}

\textbf{튜플}\textit{\textsuperscript{Tuple}}은 리스트와 유사한 형태의 자료형으로 기본적으로 내부의 원소가 변하지 않는다는 특징이 있다. 리스트와 유사하게 인덱스가 존재하여 인덱스로 원소를 추출할 수 있다. 그러나, 인덱스를 사용해 내부 원소를 바꾸는 것은 불가능하다.

튜플은 소괄호 ()를 이용해 생성하며, 튜플 간의 더하기가 가능하다. 튜플은 변경 불가능한 값이기 때문에 튜플 사이의 더하기 연산을 수행하면 아예 새로운 튜플이 튀어나오게 된다. 아래는 그 예시이다.

\begin{minipage}{\textwidth}
\begin{tcolorbox}[colframe=black, colback=white]
\begin{minted}{python}
x = (1, 2, 3)
y = x * 2
print(x + y)
\end{minted}
\end{tcolorbox}
\textbf{결과: }
\fbox{\texttt{(1, 2, 3, 1, 2, 3, 1, 2, 3)}}
\end{minipage}

튜플은 리스트와 마찬가지로 concatenate, multiply, unpacking, zipping이 모두 가능하다. delete 연산은 튜플이 수정불가능하다는 특징으로 인해 튜플 전체를 삭제하는 것만 허용된다.

아래는 튜플 관련 함수를 나타낸 것이다.

\begin{longtable}[]{@{}p{4cm} p{10cm}@{}}
    \toprule
    함수 이름 & 설명 \\
    \midrule
    \endhead
    tuple.index(x) & x 찾아서 반환 \\
    tuple.count(x) & 찾을 값 x의 개수 \\
    del(tuple) & tuple 삭제 \\
    len(tuple) & tuple의 전체 항목 개수 \\
    zip(tuple1, tuple2) & 두 튜플 tuple1, tuple2를 같은 index끼리 묶기 \\
    \bottomrule
\end{longtable}

\subsection{Dictionary}

\textbf{딕셔너리}\textit{\textsuperscript{Dictionary}}는 key:value로 구성되어 있는 가변적인 자료형이다. 딕셔너리의 내부의 요소를 추가, 삭제, 변경할 수 있다. 또한, 다양한 데이터 타입의 키와 값을 가질 수 있는 유연한 구조이다. 각 키는 고유하며, 순서는 정해져 있지 않다. (OrderedDict을 써서 순서를 정할 수도 있다.)

딕셔너리는 중괄호 \{ \}를 이용해 생성한다. 보통 딕셔너리는 키를 입력하면 값이 나오기 때문에 데이터 검색에 효율적이다. 앞서 설명했듯이 각 키는 고유하기 때문에 이미 있는 키에 대입 연산하면 기존의 값을 변경할 수 있다. 다음은 딕셔너리를 생성하는 예제이다.

\begin{minipage}{\textwidth}
\begin{tcolorbox}[colframe=black, colback=white]
\begin{minted}{python}
d = {'a': 3, 2: 7}
print(d['a'], d[2])  # 출력 순서는 실행 시마다 다를 수 있음
\end{minted}
\end{tcolorbox}
\textbf{결과: }
\fbox{\texttt{3, 7}}
\end{minipage}

아래는 딕셔너리 관련 함수를 나타낸 것이다.

\begin{longtable}[]{@{}p{4cm} p{10cm}@{}}
    \toprule
    함수 이름 & 설명\\
    \midrule
    \endhead
    dict.get(key) & key로 데이터 접근. dict{[}key{]}와 같이 간단하게 쓸 수 있음.\\
    dict.keys() & 모든 키 반환. dict\_keys({[}1,2,'a'{]})와 같은 식으로 출력됨. list(dict.keys())와 같이 list로 캐스팅하여 dict\_keys를 지울 수 있음.\\
    dict.values() & 모든 값 반환. dict\_values({[}1,2,3{]})와 같은 식으로 출력됨.\\
    dict.items() & key-value 쌍이 리스트로 묶인, 리스트가 나옴. dict\_values({[}{[}'a', 1{]},\ldots{]})과 같은 식으로 출력됨.\\
    dict in key & key 있으면 true 반환.\\
    dict.update(dict2) & 병합\\
    pop(key) & key 제거하고 값을 반환. 없으면 None.\\
    del(dict{[}key{]}) & 원소 삭제.\\
    clear() & 모든 요소 제거.\\
    \bottomrule
\end{longtable}

\subsection{String}

\textbf{문자열}\textit{\textsuperscript{String}}은 문자들의 나열로 구성된 데이터 타입이다. 즉, 글자\textit{\textsuperscript{Character}}의 리스트라고 볼 수 있다. 따라서, 리스트에서 했던 것처럼 인덱스를 활용해 글자 하나 하나에 접근이 가능하다. 주요 기능은 다음과 같다.

\begin{itemize}
    \item \textbf{인덱싱}\textit{\textsuperscript{Indexing}}: 특정 글자를 얻는다.
    \item \textbf{슬라이싱}\textit{\textsuperscript{Slicing}}: 특정 범위의 요소를 선택한다.
    \item \textbf{합치기}\textit{\textsuperscript{Concatenate}}: 문자열을 합친다. +를 이용해 간단하게 수행할 수 있다.
    \item \textbf{반복}\textit{\textsuperscript{Repetition}}: 문자열을 반복한다. *를 이용해 간단하게 수행할 수 있다.
    \item \textbf{길이}\textit{\textsuperscript{Length}}: len()로 길이를 반환한다.
\end{itemize}

아래는 문자열 관련 함수를 나타낸 것이다.

\begin{longtable}[]{@{}p{4cm} p{10cm}@{}}
    \toprule
    함수 이름 & 설명\\
    \midrule
    \endhead
    str.upper() & 모든 문자를 대문자로 만듦.\\
    str.lower() & 모든 문자를 소문자로 만듦.\\
    str.swapcase() & 모든 문자의 대/소문자를 뒤바꿈.\\
    str.title() & 모든 단어의 첫글자만 대문자로 만듦.\\
    ord(ch) & ch를 대응하는 고유한 숫자로 변환. 한글도 변환 가능하다.\\
    chr(ch) & ord와 반대로 ch에 해당하는 문자 반환.\\
    ch.islower() & 소문자인지 판별.\\
    ch.isupper() & 대문자인지 판별.\\
    \bottomrule
\end{longtable}

\subsection{Set}
\textbf{집합}\textit{\textsuperscript{Set}}은 중복되지 않는 요소들의 모임으로, 수학의 집합과 유사한 자료형이다.

집합은 중복을 허용하지 않고, 순서가 주어지지 않으며, 변경 가능한 자료형이기 때문에 요소의 추가나 삭제가 가능하다. 집합은 딕셔너리처럼 중괄호 \{ \}를 이용해 생성한다. 아래는 집합을 생성하는 예제이다.

\begin{minipage}{\textwidth}
\begin{tcolorbox}[colframe=black, colback=white]
\begin{minted}{python}
a = {1, 2, 3, 4, 5}
print(a)  # 출력 순서는 실행 시마다 다를 수 있음
\end{minted}
\end{tcolorbox}
\textbf{결과: }
\fbox{\texttt{\{1, 2, 3, 4, 5\}}}
\end{minipage}

다음은 집합의 주요한 연산을 나타낸다.

\begin{longtable}[]{@{}p{4cm} p{10cm}@{}}
    \toprule
    함수 이름 & 설명\\
    \midrule
    \endhead
    set.add(x) & set에 단일 요소 x를 추가. \\
    set.update(i) & 다른 i(리스트, 집합, 튜플 등)의 여러 요소를 추가. \\
    set.remove(x) & set에서 x 제거하고 없으면 KeyError 발생. \\
    set.discard(x) & set에서 x 있으면 제거. 없어도 에러가 발생하지 않음. \\
    set.pop() & 임의의 요소 제거하고 반환. \\
    set.clear() & set의 모든 요소 제거. \\
    set1.union(set2) & 두 집합 set1, set2의 합집합. \\
    set1.intersection(set2) & 두 집합 set1, set2의 교집합. \\
    set1.difference(set2) & 두 집합 set1, set2의 차집합. \\
    set1.symmetric\_diff\newline
    erence(set2) & 두 집합 set1, set2의 대칭 차집합(서로 공통되지 않은 요소). \\
    \bottomrule
\end{longtable}

아래의 4개 함수 union(\texttt{|}), intersection(\texttt{\&}), difference(\texttt{-}), symmetric\_difference(\texttt{\^})은 괄호 안의 연산자로 대체 가능하다.

집합은 리스트와 같이 변경 가능한 자료형을 요소로 가질 수 없다. 반면에, 변경 불가능한 자료형인 튜플은 요소로 가질 수 있다. 또한, 집합은 순서를 보장하지 않기 때문에 인덱스를 활용한 접근이 불가능하다. 인덱스를 활용한 접근이 필요하다면 list(set)을 이용하여 자료형을 리스트로 변환하여 사용할 수 있다.

\subsection{기타}
각 자료형은 서로의 자료형으로 변환이 가능하다. 함수 list(), set(), tuple(), dict()를 이용하면 된다.

아래는 리스트를 집합으로 변환하는 한가지 예제이다.

\begin{minipage}{\textwidth}
\begin{tcolorbox}[colframe=black, colback=white]
\begin{minted}{python}
my_list = [1, 2, 2, 3, 4, 4, 5]
my_set = set(my_list)
print(my_set)
\end{minted}
\end{tcolorbox}
\textbf{결과: }
\fbox{\texttt{\{1, 2, 3, 4, 5\}}}
\end{minipage}
